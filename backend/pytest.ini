[pytest]
# Test discovery
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*

# Async support
asyncio_mode = auto

# Coverage configuration
addopts = 
    -v  # Verbose output
    --cov=app  # Measure coverage for the app package
    --cov-report=term-missing  # Show missing lines in terminal
    --cov-report=html:coverage_html  # Generate HTML report
    --cov-report=xml:coverage.xml  # Generate XML report for CI
    --cov-fail-under=80  # Fail if coverage is below 80%
    -n auto  # Run tests in parallel using all available CPUs
    --durations=10  # Show 10 slowest tests
    --strict-markers  # Require markers to be registered
    --strict-config  # Strict configuration checking
    --strict  # Strict mode

# Logging configuration
log_cli = true
log_cli_level = INFO
log_cli_format = %(asctime)s [%(levelname)8s] %(message)s
log_cli_date_format = %Y-%m-%d %H:%M:%S

# Markers (register custom markers to avoid warnings)
markers =
    integration: mark test as integration test (deselect with '-m "not integration"')
    e2e: mark test as end-to-end test
    slow: mark test as slow (deselect with '-m "not slow"')
    db: test requires database access
    ldap: test requires LDAP server
    docker: test requires Docker
    skip: skip this test
    xfail: expected to fail

# Test timeouts (in seconds)
timeout = 30
timeout_method = signal

# JUnit XML output (for CI)
junit_suite_name = py-connect-tests
junit_logging = all
junit_duration_report = call
junit_family = xunit2

# Cache directory for test cache
cache_dir = .pytest_cache

# Filter warnings
filterwarnings =
    error
    ignore::DeprecationWarning
    ignore::UserWarning:.*unclosed.*
    ignore::ResourceWarning

# Test paths and module discovery
python_paths = .
python_classes = Test*
python_files = test_*.py
python_functions = test_*

# Console output options
console_output_style = classic

# Disable test capture (show stdout/stderr immediately)
# capture = no

# Show local variables in tracebacks
showlocals = True

# Show full traceback for all errors
tb = native

# Show extra test summary info
showlocals = True

# Exit on first error or failure
# exitfirst = True

# Show all warnings (even ignored ones for third-party packages)
pythonwarnings = all

# Disable test discovery in these directories
norecursedirs = 
    .git
    .tox
    .pytest_cache
    __pycache__
    build
    dist
    venv
    env
    .venv
    node_modules
    htmlcov
    coverage
    .mypy_cache
    .pytest_cache
    .vscode
    .idea
    .github
    docs
    migrations
    scripts
    tests/e2e

# Test collection and execution order
# testmon settings (for testmon plugin)
testmon_noselection = True

# Randomize test order
# random-order-bucket = module
# random-order-seed = 42

# PDB on failure
# addopts = --pdb --pdbcls=IPython.terminal.debugger:Pdb

# Custom options for specific test modules
[pytest.ini:testpaths]
# Add any test path specific configurations here

[pytest.ini:markers]
# Re-define markers here if needed for documentation

# Coverage configuration
[coverage:run]
source = app
omit = 
    */tests/*
    */migrations/*
    */__pycache__/*
    */venv/*
    */.venv/*
    */.tox/*
    */site-packages/*

[coverage:report]
exclude_lines =
    # Have to re-enable the standard pragma
    pragma: no cover
    
    # Don't complain about missing debug-only code
    def __repr__
    if self\.debug
    raise NotImplementedError
    raise ImportError
    raise Exception
    except ImportError
    except Exception
    
    # Don't complain if tests don't hit defensive assertion code
    raise AssertionError
    raise NotImplementedError
    
    # Don't complain if non-runnable code isn't run
    if 0:
    if __name__ == .__main__.:
    
    # Don't complain about abstract methods
    @(abc\.)?abstractmethod

[coverage:html]
directory = coverage_html

[coverage:xml]
output = coverage.xml

[coverage:json]
output = coverage.json

[coverage:paths]
source =
    app/
    */site-packages/
